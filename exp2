#include <iostream>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <algorithm>
#include <cstring>
#include <cctype>
using namespace std;

// 简化的位图类
class Bitmap {
private:
    unsigned char* M;
    int capacity;  // 总容量（位）
    int size;      // 当前大小（位）

public:
    Bitmap(int n = 64) {
        capacity = n;
        int bytes = (n + 7) / 8;
        M = new unsigned char[bytes];
        memset(M, 0, bytes);
        size = 0;
    }
    
    ~Bitmap() {
        delete[] M;
    }
    
    void set(int k) {
        if (k >= capacity) expand(k + 1);
        int byteIndex = k / 8;
        int bitIndex = k % 8;
        M[byteIndex] |= (1 << (7 - bitIndex));
        if (k >= size) size = k + 1;
    }
    
    void clear(int k) {
        if (k >= capacity) expand(k + 1);
        int byteIndex = k / 8;
        int bitIndex = k % 8;
        M[byteIndex] &= ~(1 << (7 - bitIndex));
    }
    
    bool test(int k) {
        if (k >= capacity) return false;
        int byteIndex = k / 8;
        int bitIndex = k % 8;
        return (M[byteIndex] & (1 << (7 - bitIndex))) != 0;
    }
    
    void expand(int newCapacity) {
        if (newCapacity <= capacity) return;
        
        int newBytes = (newCapacity + 7) / 8;
        unsigned char* newM = new unsigned char[newBytes];
        memset(newM, 0, newBytes);
        
        int oldBytes = (capacity + 7) / 8;
        memcpy(newM, M, oldBytes);
        
        delete[] M;
        M = newM;
        capacity = newCapacity;
    }
    
    string toString() {
        string result;
        for (int i = 0; i < size; i++) {
            result += test(i) ? '1' : '0';
        }
        return result;
    }
    
    int getSize() { 
        return size; 
    }
};

// Huffman编码串
class HuffCode {
private:
    Bitmap bits;

public:
    HuffCode() : bits(64) {}
    
    void append(bool bit) {
        int currentSize = bits.getSize();
        bits.set(currentSize);
        if (!bit) {
            bits.clear(currentSize);
        }
    }
    
    string toString() {
        return bits.toString();
    }
    
    void clear() {
        // 简化实现，创建新的Bitmap
        bits = Bitmap(64);
    }
    
    int size() {
        return bits.getSize();
    }
};

// 二叉树节点
struct BinNode {
    char data;
    int weight;
    BinNode* left;
    BinNode* right;
    
    BinNode(char d, int w) : data(d), weight(w), left(NULL), right(NULL) {}
};

// 用于优先队列的比较函数
struct CompareNodes {
    bool operator()(BinNode* a, BinNode* b) {
        return a->weight > b->weight;
    }
};

// Huffman树类
class HuffmanTree {
private:
    BinNode* root;
    map<char, string> codeTable;
    
    void deleteTree(BinNode* node) {
        if (node) {
            deleteTree(node->left);
            deleteTree(node->right);
            delete node;
        }
    }
    
    void generateCodes(BinNode* node, string code) {
        if (!node) return;
        
        if (!node->left && !node->right) {
            codeTable[node->data] = code;
            return;
        }
        
        generateCodes(node->left, code + "0");
        generateCodes(node->right, code + "1");
    }
    
public:
    HuffmanTree() : root(NULL) {}
    
    ~HuffmanTree() {
        deleteTree(root);
    }
    
    void build(map<char, int> freqMap) {
        // 使用优先队列
        priority_queue<BinNode*, vector<BinNode*>, CompareNodes> pq;
        
        // 创建叶子节点
        for (map<char, int>::iterator it = freqMap.begin(); it != freqMap.end(); ++it) {
            if (it->second > 0) {
                pq.push(new BinNode(it->first, it->second));
            }
        }
        
        // 构建Huffman树
        while (pq.size() > 1) {
            BinNode* left = pq.top(); 
            pq.pop();
            BinNode* right = pq.top(); 
            pq.pop();
            
            BinNode* parent = new BinNode('\0', left->weight + right->weight);
            parent->left = left;
            parent->right = right;
            
            pq.push(parent);
        }
        
        if (!pq.empty()) {
            root = pq.top();
        }
        
        // 生成编码表
        generateCodes(root, "");
    }
    
    string encode(const string& text) {
        string result;
        for (int i = 0; i < text.length(); i++) {
            char c = text[i];
            char lowerC = tolower(c);
            if (codeTable.find(lowerC) != codeTable.end()) {
                result += codeTable[lowerC];
            }
        }
        return result;
    }
    
    string decode(const string& code) {
        string result;
        BinNode* current = root;
        
        for (int i = 0; i < code.length(); i++) {
            char bit = code[i];
            if (bit == '0') {
                current = current->left;
            } else {
                current = current->right;
            }
            
            if (!current->left && !current->right) {
                result += current->data;
                current = root;
            }
        }
        
        return result;
    }
    
    void printCodeTable() {
        cout << "Huffman编码表:" << endl;
        cout << "================" << endl;
        for (map<char, string>::iterator it = codeTable.begin(); it != codeTable.end(); ++it) {
            cout << "'" << it->first << "': " << it->second << endl;
        }
        cout << "================" << endl;
    }
};

// 分析文本频率
map<char, int> analyzeText(const string& text) {
    map<char, int> freqMap;
    
    // 初始化26个字母
    for (char c = 'a'; c <= 'z'; c++) {
        freqMap[c] = 0;
    }
    
    // 统计频率
    for (int i = 0; i < text.length(); i++) {
        char c = text[i];
        if (isalpha(c)) {
            freqMap[tolower(c)]++;
        }
    }
    
    return freqMap;
}

// 马丁路德金演讲原文（简化版）
string getSpeechText() {
    return "I have a dream that one day this nation will rise up and live out the true meaning of its creed we hold these truths to be self evident that all men are created equal "
           "I have a dream that one day on the red hills of Georgia the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood "
           "I have a dream that one day even the state of Mississippi a state sweltering with the heat of injustice sweltering with the heat of oppression will be transformed into an oasis of freedom and justice "
           "I have a dream that my four little children will one day live in a nation where they will not be judged by the color of their skin but by the content of their character "
           "I have a dream today I have a dream that one day down in Alabama with its vicious racists with its governor having his lips dripping with the words of interposition and nullification "
           "one day right down in Alabama little black boys and black girls will be able to join hands with little white boys and white girls as sisters and brothers "
           "I have a dream today I have a dream that one day every valley shall be exalted every hill and mountain shall be made low the rough places will be made plain and the crooked places will be made straight "
           "and the glory of the Lord shall be revealed and all flesh shall see it together this is our hope this is the faith that I go back to the South with "
           "with this faith we will be able to hew out of the mountain of despair a stone of hope with this faith we will be able to transform the jangling discords of our nation into a beautiful symphony of brotherhood "
           "with this faith we will be able to work together to pray together to struggle together to go to jail together to stand up for freedom together knowing that we will be free one day "
           "this will be the day when all of Gods children will be able to sing with new meaning my country tis of thee sweet land of liberty of thee I sing "
           "land where my fathers died land of the pilgrims pride from every mountainside let freedom ring";
}

int main() {
    cout << "=== Huffman编码系统 ===" << endl;
    cout << "基于马丁路德金《I have a dream》演讲构建Huffman树" << endl;
    cout << "=========================================" << endl;
    
    // 获取演讲文本
    string speechText = getSpeechText();
    cout << "演讲文本长度: " << speechText.length() << " 字符" << endl;
    
    // 分析字母频率
    map<char, int> freqMap = analyzeText(speechText);
    
    cout << "\n字母频率统计:" << endl;
    cout << "================" << endl;
    int totalChars = 0;
    for (char c = 'a'; c <= 'z'; c++) {
        if (freqMap[c] > 0) {
            cout << c << ": " << freqMap[c] << "\t";
            totalChars += freqMap[c];
            if ((c - 'a') % 5 == 4) cout << endl;
        }
    }
    cout << "总字母数: " << totalChars << endl;
    cout << "================" << endl;
    
    // 构建Huffman树
    HuffmanTree huffmanTree;
    huffmanTree.build(freqMap);
    
    // 显示编码表
    cout << endl;
    huffmanTree.printCodeTable();
    
    // 测试编码解码
    string testWords[] = {"dream", "freedom", "hope", "justice", "brotherhood", "america"};
    int wordCount = 6;
    
    cout << "\n单词编码测试:" << endl;
    cout << "================" << endl;
    for (int i = 0; i < wordCount; i++) {
        string word = testWords[i];
        string encoded = huffmanTree.encode(word);
        string decoded = huffmanTree.decode(encoded);
        
        cout << "单词: " << word << endl;
        cout << "编码: " << encoded << endl;
        cout << "解码: " << decoded << endl;
        cout << "编码长度: " << encoded.length() << " 位" << endl;
        if (encoded.length() > 0) {
            cout << "压缩比: " << (word.length() * 8.0 / encoded.length()) << ":1" << endl;
        }
        cout << "---" << endl;
    }
    
    // 测试HuffCode类
    cout << "\n测试HuffCode类:" << endl;
    cout << "================" << endl;
    HuffCode huffCode;
    string testWord = "test";
    string testEncoded = huffmanTree.encode(testWord);
    
    cout << "测试单词: " << testWord << endl;
    cout << "Huffman编码: " << testEncoded << endl;
    
    // 使用HuffCode类存储编码
    for (int i = 0; i < testEncoded.length(); i++) {
        huffCode.append(testEncoded[i] == '1');
    }
    
    cout << "HuffCode内容: " << huffCode.toString() << endl;
    cout << "HuffCode长度: " << huffCode.size() << " 位" << endl;
    
    cout << "\n=== 程序运行完成 ===" << endl;
    
    // 等待用户输入
    cout << "按Enter键退出...";
    cin.get();
    
    return 0;
}
