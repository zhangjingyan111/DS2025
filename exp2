#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <climits>
using namespace std;

// 位图类（按题目要求实现）
class Bitmap {
private:
    unsigned char* M;
    int N;  // 字节数
    int _sz; // 有效位个数
    void expand(int k) { // 扩容至能容纳第k位
        if (k < 8 * N) return;
        int oldN = N;
        unsigned char* oldM = M;
        N = (2 * k + 7) / 8; // 加倍策略扩容
        M = new unsigned char[N];
        memset(M, 0, N);
        memcpy(M, oldM, oldN); // 复制原数据
        delete[] oldM;
    }
public:
    Bitmap(int n = 8) { // 构造函数
        N = (n + 7) / 8;
        M = new unsigned char[N];
        memset(M, 0, N);
        _sz = 0;
    }
    ~Bitmap() { // 析构函数
        delete[] M;
        M = NULL;
        _sz = 0;
        N = 0;
    }
    int size() { return _sz; }
    void set(int k) { // 设置第k位为1
        expand(k);
        if (!test(k)) { // 未设置过才计数
            _sz++;
            M[k >> 3] |= (0x80 >> (k & 0x07));
        }
    }
    void clear(int k) { // 清除第k位为0
        expand(k);
        if (test(k)) { // 已设置过才计数
            _sz--;
            M[k >> 3] &= ~(0x80 >> (k & 0x07));
        }
    }
    bool test(int k) { // 测试第k位是否为1
        expand(k);
        return M[k >> 3] & (0x80 >> (k & 0x07));
    }
    char* bits2string(int n) { // 转换前n位为字符串
        expand(n - 1);
        char* s = new char[n + 1];
        s[n] = '\0';
        for (int i = 0; i < n; i++) {
            s[i] = test(i) ? '1' : '0';
        }
        return s;
    }
};

// 二叉树节点结构
template <typename T>
struct BinNode {
    T data;
    BinNode* left;
    BinNode* right;
    BinNode(T d = T(), BinNode* l = NULL, BinNode* r = NULL) {
        data = d;
        left = l;
        right = r;
    }
};

// Huffman树节点（继承二叉树节点，增加权重和字符）
struct HuffNode : public BinNode<int> {
    char ch; // 对应的字符（仅叶子节点有效）
    int weight; // 权重（出现次数）
    HuffNode(char c = '\0', int w = 0, HuffNode* l = NULL, HuffNode* r = NULL) {
        ch = c;
        weight = w;
        left = l;
        right = r;
    }
};

// 最小堆（用于构建Huffman树）
class MinHeap {
private:
    HuffNode** heap;
    int size;
    int capacity;
    void shiftUp(int i) { // 向上调整
        while (i > 0 && heap[(i - 1) / 2]->weight > heap[i]->weight) {
            swap(heap[i], heap[(i - 1) / 2]);
            i = (i - 1) / 2;
        }
    }
    void shiftDown(int i) { // 向下调整
        int minIdx = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        if (left < size && heap[left]->weight < heap[minIdx]->weight) minIdx = left;
        if (right < size && heap[right]->weight < heap[minIdx]->weight) minIdx = right;
        if (minIdx != i) {
            swap(heap[i], heap[minIdx]);
            shiftDown(minIdx);
        }
    }
public:
    MinHeap(int cap = 26) { // 初始容量26（26个字母）
        capacity = cap;
        size = 0;
        heap = new HuffNode*[capacity];
    }
    ~MinHeap() {
        for (int i = 0; i < size; i++) delete heap[i];
        delete[] heap;
    }
    bool isEmpty() { return size == 0; }
    void insert(HuffNode* node) { // 插入节点
        if (size >= capacity) { // 扩容
            capacity *= 2;
            HuffNode** newHeap = new HuffNode*[capacity];
            memcpy(newHeap, heap, size * sizeof(HuffNode*));
            delete[] heap;
            heap = newHeap;
        }
        heap[size++] = node;
        shiftUp(size - 1);
    }
    HuffNode* extractMin() { // 提取最小权重节点
        if (isEmpty()) return NULL;
        HuffNode* minNode = heap[0];
        heap[0] = heap[--size];
        shiftDown(0);
        return minNode;
    }
};

// Huffman编码类（新增clear成员函数，修复报错）
class HuffCode {
private:
    Bitmap code; // 存储编码的位图
    int length; // 编码长度
public:
    HuffCode() { length = 0; }
    ~HuffCode() {}
    void appendBit(bool bit) { // 追加一个比特
        code.set(length);
        if (!bit) code.clear(length);
        length++;
    }
    char* toString() { // 转换为字符串
        return code.bits2string(length);
    }
    int getLength() { return length; }
    // 新增：清除第k位（用于回溯）
    void clear(int k) {
        if (k >= 0 && k < length) {
            code.clear(k);
        }
    }
};

// 全局变量：存储每个字符的Huffman编码
HuffCode huffCodes[26];

// 构建Huffman编码（递归遍历Huffman树）
void buildHuffCodes(HuffNode* root, HuffCode currentCode) {
    if (root == NULL) return;
    // 叶子节点（对应单个字符）
    if (root->left == NULL && root->right == NULL) {
        int idx = root->ch - 'a';
        huffCodes[idx] = currentCode;
        return;
    }
    // 左子树：追加0
    currentCode.appendBit(false);
    buildHuffCodes((HuffNode*)root->left, currentCode);
    currentCode.clear(currentCode.getLength() - 1); // 回溯（现在有clear函数，无报错）
    // 右子树：追加1
    currentCode.appendBit(true);
    buildHuffCodes((HuffNode*)root->right, currentCode);
    currentCode.clear(currentCode.getLength() - 1); // 回溯
}

// 构建Huffman树
HuffNode* buildHuffTree(int freq[]) {
    MinHeap heap;
    // 插入所有有频率的字符节点
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            HuffNode* node = new HuffNode('a' + i, freq[i]);
            heap.insert(node);
        }
    }
    // 构建Huffman树
    while (heap.isEmpty() == false) {
        HuffNode* left = heap.extractMin();
        if (heap.isEmpty()) { // 只剩一个节点（树构建完成）
            return left;
        }
        HuffNode* right = heap.extractMin();
        // 创建父节点（权重为左右子节点之和，字符设为无效）
        HuffNode* parent = new HuffNode('\0', left->weight + right->weight, left, right);
        heap.insert(parent);
    }
    return NULL;
}

// 统计《I have a dream》中26个字母的频率（不分大小写）
void countFrequencies(int freq[]) {
    memset(freq, 0, 26 * sizeof(int));
    // 《I have a dream》核心文本（含重复出现的字母）
    const char* text = "I have a dream that one day this nation will rise up and live out the true meaning of its creed We hold these truths to be self evident that all men are created equal";
    for (int i = 0; text[i] != '\0'; i++) {
        char c = tolower(text[i]);
        if (c >= 'a' && c <= 'z') {
            freq[c - 'a']++;
        }
    }
}

// 对单词进行Huffman编码
char* encodeWord(const char* word) {
    if (word == NULL || word[0] == '\0') return NULL;
    // 计算总编码长度
    int totalLen = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        char c = tolower(word[i]);
        if (c < 'a' || c > 'z') return NULL; // 只处理字母
        totalLen += huffCodes[c - 'a'].getLength();
    }
    // 拼接所有字符的编码
    char* result = new char[totalLen + 1];
    result[totalLen] = '\0';
    int pos = 0;
    for (int i = 0; word[i] != '\0'; i++) {
        char c = tolower(word[i]);
        char* codeStr = huffCodes[c - 'a'].toString();
        strcpy(result + pos, codeStr);
        pos += strlen(codeStr);
        delete[] codeStr;
    }
    return result;
}

// 声明释放函数（避免编译警告）
void releaseHuffTree(HuffNode*);

int main() {
    int freq[26];
    // 1. 统计字母频率
    countFrequencies(freq);
    cout << "26个字母在《I have a dream》中的出现频率：" << endl;
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            cout << (char)('a' + i) << ": " << freq[i] << "次" << endl;
        }
    }
    cout << endl;

    // 2. 构建Huffman树
    HuffNode* huffRoot = buildHuffTree(freq);
    if (huffRoot == NULL) {
        cout << "构建Huffman树失败！" << endl;
        return 1;
    }

    // 3. 构建Huffman编码
    HuffCode emptyCode;
    buildHuffCodes(huffRoot, emptyCode);
    cout << "各字母的Huffman编码：" << endl;
    for (int i = 0; i < 26; i++) {
        if (freq[i] > 0) {
            cout << (char)('a' + i) << ": " << huffCodes[i].toString() << endl;
        }
    }
    cout << endl;

    // 4. 对指定单词进行编码（包含dream及自选单词）
    const char* testWords[] = {"dream", "nation", "equal", "freedom", "hope", NULL};
    cout << "单词编码结果：" << endl;
    for (int i = 0; testWords[i] != NULL; i++) {
        char* code = encodeWord(testWords[i]);
        cout << testWords[i] << ": " << (code ? code : "包含非字母字符") << endl;
        delete[] code;
    }

    // 释放Huffman树内存
    releaseHuffTree(huffRoot);
    return 0;
}

// 递归释放Huffman树内存
void releaseHuffTree(HuffNode* root) {
    if (root == NULL) return;
    releaseHuffTree((HuffNode*)root->left);
    releaseHuffTree((HuffNode*)root->right);
    delete root;
}
